<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE log SYSTEM "logger.dtd">
<log>
File Measures: 
	Number of req in file = 33
	Number of prim req in file = 33
<FailedRequirement>
</FailedRequirement>
<SucceededRequirement>
	<Requirement>
		ID: [req_2:]
		text: the parking sensor beeps while an obstacle is detected.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the parking sensor beeps while an obstacle is detected.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [G( (((R)) ∧ ¬ ((¬Q)) ∧ F((¬Q))) ==> (F((P) || ((¬Q)) ) U ((¬Q))) )] )
					MTL-Formula: G( [G( (((an obstacle.crrStatus = detect)) ∧ ¬ ((¬an obstacle.crrStatus = detect)) ∧ F((¬an obstacle.crrStatus = detect))) ==> (F((the parking sensor.crrStatus = beep) || ((¬an obstacle.crrStatus = detect)) ) U ((¬an obstacle.crrStatus = detect))) )] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the parking sensor beeps
					[2]: while an obstacle is detected
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the parking sensor beeps
					C[2]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= while an obstacle is detected
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the parking sensor beeps
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the parking sensor
							</ArgDetails>
						</Operands>
						<Operator>
							relation:beeps
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: beep
							TechnicalOperator: =
							PredicateFormal: the parking sensor.crrStatus = beep
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<LogicalRelation>
								relation: AND
							</LogicalRelation>
								<ConditionalScope>
									scope phase: StartUpPhase
									<Condition>
										Keyword: after
										Text = while an obstacle is detected
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: an obstacle
											</ArgDetails>
										</Operands>
										<Operator>
											relation:is detected
										</Operator>
										Has valid-time:  false
										Is negatted: false
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: detect
											TechnicalOperator: =
											PredicateFormal: an obstacle.crrStatus = detect
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
								<ConditionalScope>
									scope phase: EndUpPhase
									<Condition>
										Keyword: until
										Text = while an obstacle is detected
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: an obstacle
											</ArgDetails>
										</Operands>
										<Operator>
											relation:is detected
										</Operator>
										Has valid-time:  false
										Is negatted: true
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: detect
											TechnicalOperator: =
											PredicateFormal: an obstacle.crrStatus = detect
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_6:]
		text: the parking sensor beeps for at most 10 seconds while an obstacle is detected.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the parking sensor beeps for at most 10 seconds while an obstacle is detected.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [G( (((R)) ∧ ¬ ((¬Q)) ∧ F((¬Q))) ==> (F((G{t<=10}(P)) || ((¬Q)) ) U ((¬Q))) )] )
					MTL-Formula: G( [G( (((an obstacle.crrStatus = detect)) ∧ ¬ ((¬an obstacle.crrStatus = detect)) ∧ F((¬an obstacle.crrStatus = detect))) ==> (F((G{t<=10}(the parking sensor.crrStatus = beep)) || ((¬an obstacle.crrStatus = detect)) ) U ((¬an obstacle.crrStatus = detect))) )] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the parking sensor beeps for at most 10 seconds
					[2]: while an obstacle is detected
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the parking sensor beeps
						SlotType= TimeScope|| Text= for at  most 10 seconds
					C[2]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= while an obstacle is detected
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the parking sensor beeps
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the parking sensor
							</ArgDetails>
						</Operands>
						<Operator>
							relation:beeps
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 10
							Unit: seconds
							QPRelation: at  most
						<FormalSemantic>
							TechnicalOperator: <=
							Value: 10
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: beep
							TechnicalOperator: =
							PredicateFormal: the parking sensor.crrStatus = beep
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<LogicalRelation>
								relation: AND
							</LogicalRelation>
								<ConditionalScope>
									scope phase: StartUpPhase
									<Condition>
										Keyword: after
										Text = while an obstacle is detected
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: an obstacle
											</ArgDetails>
										</Operands>
										<Operator>
											relation:is detected
										</Operator>
										Has valid-time:  false
										Is negatted: false
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: detect
											TechnicalOperator: =
											PredicateFormal: an obstacle.crrStatus = detect
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
								<ConditionalScope>
									scope phase: EndUpPhase
									<Condition>
										Keyword: until
										Text = while an obstacle is detected
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: an obstacle
											</ArgDetails>
										</Operands>
										<Operator>
											relation:is detected
										</Operator>
										Has valid-time:  false
										Is negatted: true
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: detect
											TechnicalOperator: =
											PredicateFormal: an obstacle.crrStatus = detect
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_4:]
		text: the fuel display blinks if the fuel level is low.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the fuel display blinks if the fuel level is low.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(Q)] )
					MTL-Formula: G( [(the fuel level = low)] ==> [(the fuel display.crrStatus = blink)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the fuel display blinks
					[2]: if the fuel level is low
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the fuel display blinks
					C[2]==>	Type: cond 
						SlotType= MainSlot|| Text= if the fuel level is low
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if the fuel level is low
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the fuel level
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: low
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the fuel level = low
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the fuel display blinks
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the fuel display
							</ArgDetails>
						</Operands>
						<Operator>
							relation:blinks
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: blink
							TechnicalOperator: =
							PredicateFormal: the fuel display.crrStatus = blink
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_8:]
		text: if a crash is detected, an emergency signal is sent within 10 second.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if a crash is detected, an emergency signal is sent within 10 second.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(F{t=10}(Q))] )
					MTL-Formula: G( [(a crash.crrStatus = detect)] ==> [(F{t=10}(an emergency signal.crrStatus = send))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if a crash is detected
					[2]: an emergency signal is sent within 10 second
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if a crash is detected
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= an emergency signal is sent
						SlotType= TimeScope|| Text= within 10 second
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if a crash is detected
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: a crash
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is detected
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: detect
							TechnicalOperator: =
							PredicateFormal: a crash.crrStatus = detect
						</FormalSemantic>
					</Condition>
					<Action>
						Text = an emergency signal is sent
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: an emergency signal
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is sent
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: send
							TechnicalOperator: =
							PredicateFormal: an emergency signal.crrStatus = send
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 10
							Unit: second
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 10
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_24:]
		text: the display elements glow.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the display elements glow.
				<Formal-Representation>
					MTL-AbbrevatedFormula: 
					MTL-Formula: 
				</Formal-Representation>
				<ExtractedComponents>
				</ExtractedComponents>
				<ClassifiedComponents>
				</ClassifiedComponents>
				<RCMDetails>
					
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_14:]
		text: if it rains, the wipers are RCMVAL_on for 30 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains, the wipers are RCMVAL_on for 30 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(G{t=30}(Q))] )
					MTL-Formula: G( [(it.crrStatus = rain)] ==> [(G{t=30}(the wipers = RCMVAL_on))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains
					[2]: the wipers are RCMVAL_on for 30 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are RCMVAL_on
						SlotType= TimeScope|| Text= for 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are RCMVAL_on
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: RCMVAL_on
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = RCMVAL_on
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_22:]
		text: the electricity circuit is active.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the electricity circuit is active.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] )
					MTL-Formula: G( [(the electricity circuit = active)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the electricity circuit is active
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the electricity circuit is active
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the electricity circuit is active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the electricity circuit
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the electricity circuit = active
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_16:]
		text: if it rains for 1 minute, the wipers are activated.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains for 1 minute, the wipers are activated.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(G{t=1}(P))] ==> [(Q)] )
					MTL-Formula: G( [(G{t=1}(it.crrStatus = rain))] ==> [(the wipers.crrStatus = activate)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains for 1 minute
					[2]: the wipers are activated
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
						SlotType= TimeScope|| Text= for 1 minute
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are activated
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are activated
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are activated
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: activate
							TechnicalOperator: =
							PredicateFormal: the wipers.crrStatus = activate
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_26:]
		text: the radio is powered within 5 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the radio is powered within 5 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(F{t=5}(P))] )
					MTL-Formula: G( [(F{t=5}(the radio.crrStatus = power))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the radio is powered within 5 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the radio is powered
						SlotType= TimeScope|| Text= within 5 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the radio is powered
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the radio
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is powered
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: power
							TechnicalOperator: =
							PredicateFormal: the radio.crrStatus = power
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 5
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 5
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_28:]
		text: the airbag is not activated before a crash is detected.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the airbag is not activated before a crash is detected.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [F(Q) ==> (F((¬P) || (Q) ) U (Q))] )
					MTL-Formula: G( [F(a crash.crrStatus = detect) ==> (F((¬the airbag.crrStatus = activate) || (a crash.crrStatus = detect) ) U (a crash.crrStatus = detect))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the airbag is not activated
					[2]: before a crash is detected
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the airbag is not activated
					C[2]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= before a crash is detected
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the airbag is not activated
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the airbag
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is activated
						</Operator>
						Has valid-time:  false
						Is negatted: true
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: activate
							TechnicalOperator: =
							PredicateFormal: the airbag.crrStatus = activate
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<ConditionalScope>
								scope phase: EndUpPhase
								<Condition>
									Keyword: null
									Text = before a crash is detected
									<Operands>
										Arg[0]
										<ArgDetails>
											Text: a crash
										</ArgDetails>
									</Operands>
									<Operator>
										relation:is detected
									</Operator>
									Has valid-time:  false
									Is negatted: false
									<FormalSemantic>
										LHS: Arg[0].crrStatus
										RHS: detect
										TechnicalOperator: =
										PredicateFormal: a crash.crrStatus = detect
									</FormalSemantic>
								</Condition>
							</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_12:]
		text: if it rains and the wipers are active, the wipers are active for 30 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains and the wipers are active, the wipers are active for 30 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [R ∧ S] ==> [G{t=30}(Q)] )
					MTL-Formula: G( [(it = rains ∧ the wipers = active)] ==> [G{t=30}(the wipers = active)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains
					[2]: the wipers are active
					[3]: the wipers are active for 30 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
				  	C[1]==>	Type: Condition 
						SlotType= MainSlot|| Text= if it rains
				        C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
					C[3]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
						SlotType= TimeScope|| Text= for 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Mentioned text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has scope:  false
						Is negatted = false
					</Condition>
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_20:]
		text: if it rains for 1 minute, the wipers are active within 1 minute.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains for 1 minute, the wipers are active within 1 minute.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(G{t=1}(P))] ==> [(F{t=1}(Q))] )
					MTL-Formula: G( [(G{t=1}(it.crrStatus = rain))] ==> [(F{t=1}(the wipers = active))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains for 1 minute
					[2]: the wipers are active within 1 minute
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
						SlotType= TimeScope|| Text= for 1 minute
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
						SlotType= TimeScope|| Text= within 1 minute
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_10:]
		text: if a crash is detected, an emergency signal is sent.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if a crash is detected, an emergency signal is sent.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(Q)] )
					MTL-Formula: G( [(a crash.crrStatus = detect)] ==> [(an emergency signal.crrStatus = send)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if a crash is detected
					[2]: an emergency signal is sent
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if a crash is detected
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= an emergency signal is sent
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if a crash is detected
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: a crash
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is detected
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: detect
							TechnicalOperator: =
							PredicateFormal: a crash.crrStatus = detect
						</FormalSemantic>
					</Condition>
					<Action>
						Text = an emergency signal is sent
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: an emergency signal
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is sent
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: send
							TechnicalOperator: =
							PredicateFormal: an emergency signal.crrStatus = send
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_30:]
		text: if it is dark, the lights are RCMVAL_on before it is bright for at most 10 minutes.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it is dark, the lights are RCMVAL_on before it is bright for at most 10 minutes.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [F(R) ==> (F((G{t<=10}(Q)) || (R) ) U (R))] )
					MTL-Formula: G( [(it = dark)] ==> [F(it = bright) ==> (F((G{t<=10}(the lights = RCMVAL_on)) || (it = bright) ) U (it = bright))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it is dark
					[2]: the lights are RCMVAL_on before it is bright for at most 10 minutes
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it is dark
					C[2]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= before it is bright
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the lights are RCMVAL_on
						SlotType= TimeScope|| Text= for at  most 10 minutes
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it is dark
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: dark
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: it = dark
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the lights are RCMVAL_on
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the lights
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: RCMVAL_on
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 10
							Unit: minutes
							QPRelation: at  most
						<FormalSemantic>
							TechnicalOperator: <=
							Value: 10
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the lights = RCMVAL_on
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<ConditionalScope>
								scope phase: EndUpPhase
								<Condition>
									Keyword: null
									Text = before it is bright
									<Operands>
										Arg[0]
										<ArgDetails>
											Text: it
										</ArgDetails>
										Arg[1]
										<ArgDetails>
											Text: bright
										</ArgDetails>
									</Operands>
									<Operator>
										relation:is
									</Operator>
									Has valid-time:  false
									Is negatted: false
									<FormalSemantic>
										LHS: Arg[0]
										RHS: Arg[1]
										TechnicalOperator: =
										PredicateFormal: it = bright
									</FormalSemantic>
								</Condition>
							</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_18:]
		text: if it rains for 1 minute, the wipers are activated within 30 seconds before the windscreen is dry.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains for 1 minute, the wipers are activated within 30 seconds before the windscreen is dry.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(G{t=1}(P))] ==> [F(R) ==> (F((F{t=30}(Q)) || (R) ) U (R))] )
					MTL-Formula: G( [(G{t=1}(it.crrStatus = rain))] ==> [F(the windscreen = dry) ==> (F((F{t=30}(the wipers.crrStatus = activate)) || (the windscreen = dry) ) U (the windscreen = dry))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains for 1 minute
					[2]: the wipers are activated within 30 seconds
					[3]: before the windscreen is dry
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
						SlotType= TimeScope|| Text= for 1 minute
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are activated
						SlotType= TimeScope|| Text= within 30 seconds
					C[3]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= before the windscreen is dry
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are activated
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are activated
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: activate
							TechnicalOperator: =
							PredicateFormal: the wipers.crrStatus = activate
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
						<ActionScope>
							<ConditionalScope>
								scope phase: EndUpPhase
								<Condition>
									Keyword: null
									Text = before the windscreen is dry
									<Operands>
										Arg[0]
										<ArgDetails>
											Text: the windscreen
										</ArgDetails>
										Arg[1]
										<ArgDetails>
											Text: dry
										</ArgDetails>
									</Operands>
									<Operator>
										relation:is
									</Operator>
									Has valid-time:  false
									Is negatted: false
									<FormalSemantic>
										LHS: Arg[0]
										RHS: Arg[1]
										TechnicalOperator: =
										PredicateFormal: the windscreen = dry
									</FormalSemantic>
								</Condition>
							</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_3:]
		text: the fuel display blinks while the fuel level is low.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the fuel display blinks while the fuel level is low.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [G( (((R)) ∧ ¬ ((¬Q)) ∧ F((¬Q))) ==> (F((P) || ((¬Q)) ) U ((¬Q))) )] )
					MTL-Formula: G( [G( (((the fuel level = low)) ∧ ¬ ((¬the fuel level = low)) ∧ F((¬the fuel level = low))) ==> (F((the fuel display.crrStatus = blink) || ((¬the fuel level = low)) ) U ((¬the fuel level = low))) )] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the fuel display blinks
					[2]: while the fuel level is low
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the fuel display blinks
					C[2]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= while the fuel level is low
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the fuel display blinks
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the fuel display
							</ArgDetails>
						</Operands>
						<Operator>
							relation:blinks
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: blink
							TechnicalOperator: =
							PredicateFormal: the fuel display.crrStatus = blink
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<LogicalRelation>
								relation: AND
							</LogicalRelation>
								<ConditionalScope>
									scope phase: StartUpPhase
									<Condition>
										Keyword: after
										Text = while the fuel level is low
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: the fuel level
											</ArgDetails>
											Arg[1]
											<ArgDetails>
												Text: low
											</ArgDetails>
										</Operands>
										<Operator>
											relation:is
										</Operator>
										Has valid-time:  false
										Is negatted: false
										<FormalSemantic>
											LHS: Arg[0]
											RHS: Arg[1]
											TechnicalOperator: =
											PredicateFormal: the fuel level = low
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
								<ConditionalScope>
									scope phase: EndUpPhase
									<Condition>
										Keyword: until
										Text = while the fuel level is low
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: the fuel level
											</ArgDetails>
											Arg[1]
											<ArgDetails>
												Text: low
											</ArgDetails>
										</Operands>
										<Operator>
											relation:is
										</Operator>
										Has valid-time:  false
										Is negatted: true
										<FormalSemantic>
											LHS: Arg[0]
											RHS: Arg[1]
											TechnicalOperator: =
											PredicateFormal: the fuel level = low
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_1:]
		text:  the wipers are active while it rains.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text:  the wipers are active while it rains.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [G( (((R)) ∧ ¬ ((¬Q)) ∧ F((¬Q))) ==> (F((P) || ((¬Q)) ) U ((¬Q))) )] )
					MTL-Formula: G( [G( (((it.crrStatus = rain)) ∧ ¬ ((¬it.crrStatus = rain)) ∧ F((¬it.crrStatus = rain))) ==> (F((the wipers = active) || ((¬it.crrStatus = rain)) ) U ((¬it.crrStatus = rain))) )] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the wipers are active while it rains
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= while it rains
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<LogicalRelation>
								relation: AND
							</LogicalRelation>
								<ConditionalScope>
									scope phase: StartUpPhase
									<Condition>
										Keyword: after
										Text = while it rains
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: it
											</ArgDetails>
										</Operands>
										<Operator>
											relation:rains
										</Operator>
										Has valid-time:  false
										Is negatted: false
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: rain
											TechnicalOperator: =
											PredicateFormal: it.crrStatus = rain
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
								<ConditionalScope>
									scope phase: EndUpPhase
									<Condition>
										Keyword: until
										Text = while it rains
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: it
											</ArgDetails>
										</Operands>
										<Operator>
											relation:rains
										</Operator>
										Has valid-time:  false
										Is negatted: true
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: rain
											TechnicalOperator: =
											PredicateFormal: it.crrStatus = rain
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_7:]
		text: the fuel display blinks for at most 10 seconds if the fuel level is low.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the fuel display blinks for at most 10 seconds if the fuel level is low.
				<Formal-Representation>
					MTL-AbbrevatedFormula: 
					MTL-Formula: 
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the fuel display blinks for at most 10 seconds
					[2]: if the fuel level is low
				</ExtractedComponents>
				<ClassifiedComponents>
					C[2]==>	Type: cond 
						SlotType= MainSlot|| Text= if the fuel level is low
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if the fuel level is low
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the fuel level
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: low
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the fuel level = low
						</FormalSemantic>
					</Condition>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_5:]
		text: the wipers are active for at most 10 seconds while it rains.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the wipers are active for at most 10 seconds while it rains.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [G( (((R)) ∧ ¬ ((¬Q)) ∧ F((¬Q))) ==> (F((G{t<=10}(P)) || ((¬Q)) ) U ((¬Q))) )] )
					MTL-Formula: G( [G( (((it.crrStatus = rain)) ∧ ¬ ((¬it.crrStatus = rain)) ∧ F((¬it.crrStatus = rain))) ==> (F((G{t<=10}(the wipers = active)) || ((¬it.crrStatus = rain)) ) U ((¬it.crrStatus = rain))) )] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the wipers are active for at most 10 seconds while it rains
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= while it rains
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
						SlotType= TimeScope|| Text= for at  most 10 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 10
							Unit: seconds
							QPRelation: at  most
						<FormalSemantic>
							TechnicalOperator: <=
							Value: 10
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<LogicalRelation>
								relation: AND
							</LogicalRelation>
								<ConditionalScope>
									scope phase: StartUpPhase
									<Condition>
										Keyword: after
										Text = while it rains
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: it
											</ArgDetails>
										</Operands>
										<Operator>
											relation:rains
										</Operator>
										Has valid-time:  false
										Is negatted: false
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: rain
											TechnicalOperator: =
											PredicateFormal: it.crrStatus = rain
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
								<ConditionalScope>
									scope phase: EndUpPhase
									<Condition>
										Keyword: until
										Text = while it rains
										<Operands>
											Arg[0]
											<ArgDetails>
												Text: it
											</ArgDetails>
										</Operands>
										<Operator>
											relation:rains
										</Operator>
										Has valid-time:  false
										Is negatted: true
										<FormalSemantic>
											LHS: Arg[0].crrStatus
											RHS: rain
											TechnicalOperator: =
											PredicateFormal: it.crrStatus = rain
										</FormalSemantic>
									</Condition>
								</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_9:]
		text: if a crash is detected, an emergency signal is sent within 10 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if a crash is detected, an emergency signal is sent within 10 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(F{t=10}(Q))] )
					MTL-Formula: G( [(a crash.crrStatus = detect)] ==> [(F{t=10}(an emergency signal.crrStatus = send))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if a crash is detected
					[2]: an emergency signal is sent within 10 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if a crash is detected
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= an emergency signal is sent
						SlotType= TimeScope|| Text= within 10 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if a crash is detected
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: a crash
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is detected
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: detect
							TechnicalOperator: =
							PredicateFormal: a crash.crrStatus = detect
						</FormalSemantic>
					</Condition>
					<Action>
						Text = an emergency signal is sent
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: an emergency signal
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is sent
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: send
							TechnicalOperator: =
							PredicateFormal: an emergency signal.crrStatus = send
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 10
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 10
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_25:]
		text: the motor is RCMVAL_on within 1 second.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the motor is RCMVAL_on within 1 second.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(F{t=1}(P))] )
					MTL-Formula: G( [(F{t=1}(the motor = RCMVAL_on))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the motor is RCMVAL_on within 1 second
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the motor is RCMVAL_on
						SlotType= TimeScope|| Text= within 1 second
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the motor is RCMVAL_on
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the motor
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: RCMVAL_on
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the motor = RCMVAL_on
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 1
							Unit: second
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_15:]
		text: if it rains, the wipers are RCMVAL_on after 30 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains, the wipers are RCMVAL_on after 30 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(F{t=30}(Q))] )
					MTL-Formula: G( [(it.crrStatus = rain)] ==> [(F{t=30}(the wipers = RCMVAL_on))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains
					[2]: the wipers are RCMVAL_on after 30 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are RCMVAL_on
						SlotType= TimeScope|| Text= after 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are RCMVAL_on
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: RCMVAL_on
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = RCMVAL_on
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_23:]
		text: the light is RCMVAL_on.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the light is RCMVAL_on.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] )
					MTL-Formula: G( [(the light = RCMVAL_on)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the light is RCMVAL_on
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the light is RCMVAL_on
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the light is RCMVAL_on
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the light
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: RCMVAL_on
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the light = RCMVAL_on
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_13:]
		text: if it rains, the wipers are RCMVAL_on for 30 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains, the wipers are RCMVAL_on for 30 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [(G{t=30}(Q))] )
					MTL-Formula: G( [(it.crrStatus = rain)] ==> [(G{t=30}(the wipers = RCMVAL_on))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains
					[2]: the wipers are RCMVAL_on for 30 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are RCMVAL_on
						SlotType= TimeScope|| Text= for 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are RCMVAL_on
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: RCMVAL_on
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = RCMVAL_on
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_17:]
		text: if it rains for 1 minute, the wipers are activated within 30 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains for 1 minute, the wipers are activated within 30 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(G{t=1}(P))] ==> [(F{t=30}(Q))] )
					MTL-Formula: G( [(G{t=1}(it.crrStatus = rain))] ==> [(F{t=30}(the wipers.crrStatus = activate))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains for 1 minute
					[2]: the wipers are activated within 30 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
						SlotType= TimeScope|| Text= for 1 minute
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are activated
						SlotType= TimeScope|| Text= within 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are activated
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are activated
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: activate
							TechnicalOperator: =
							PredicateFormal: the wipers.crrStatus = activate
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_27:]
		text: the airbag is activated after a crash is detected.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: the airbag is activated after a crash is detected.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [((Q) ==> (P))] )
					MTL-Formula: G( [((a crash.crrStatus = detect) ==> (the airbag.crrStatus = activate))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: the airbag is activated
					[2]: after a crash is detected
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: act 
						SlotType= MainSlot|| Text= the airbag is activated
					C[2]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= after a crash is detected
				</ClassifiedComponents>
				<RCMDetails>
					
					<Action>
						Text = the airbag is activated
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the airbag
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is activated
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: activate
							TechnicalOperator: =
							PredicateFormal: the airbag.crrStatus = activate
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<ConditionalScope>
								scope phase: StartUpPhase
								<Condition>
									Keyword: null
									Text = after a crash is detected
									<Operands>
										Arg[0]
										<ArgDetails>
											Text: a crash
										</ArgDetails>
									</Operands>
									<Operator>
										relation:is detected
									</Operator>
									Has valid-time:  false
									Is negatted: false
									<FormalSemantic>
										LHS: Arg[0].crrStatus
										RHS: detect
										TechnicalOperator: =
										PredicateFormal: a crash.crrStatus = detect
									</FormalSemantic>
								</Condition>
							</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_21:]
		text: if it rains for 1 minute, the wipers are active for 30 seconds after 1 minute.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains for 1 minute, the wipers are active for 30 seconds after 1 minute.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(G{t=1}(P))] ==> [(F{t=1}(G{t=30}(Q)))] )
					MTL-Formula: G( [(G{t=1}(it.crrStatus = rain))] ==> [(F{t=1}(G{t=30}(the wipers = active)))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains for 1 minute
					[2]: the wipers are active for 30 seconds after 1 minute
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
						SlotType= TimeScope|| Text= for 1 minute
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
						SlotType= TimeScope|| Text= after 1 minute
						SlotType= TimeScope|| Text= for 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_11:]
		text: if it rains and the wipers are active, the wipers are active for 30 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains and the wipers are active, the wipers are active for 30 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [R ∧ S] ==> [G{t=30}(Q)] )
					MTL-Formula: G( [(it = rains ∧ the wipers = active)] ==> [G{t=30}(the wipers = active)] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains
					[2]: the wipers are active
					[3]: the wipers are active for 30 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: Condition 
						SlotType= MainSlot|| Text= if it rains
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
					C[3]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
						SlotType= TimeScope|| Text= for 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Mentioned text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has scope:  false
						Is negatted = false
					</Condition>
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_31:]
		text: if a crash is detected, the airbag is activated within 5 ms, after
an emergency signal is sent for 10 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if a crash is detected, the airbag is activated within 5 ms, after an emergency signal is sent for 10 seconds..
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(P)] ==> [((G{t=10}(R)) ==> (F{t=5}(Q)))] )
					MTL-Formula: G( [(a crash.crrStatus = detect)] ==> [((G{t=10}(an emergency signal.crrStatus = send)) ==> (F{t=5}(the airbag.crrStatus = activate)))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if a crash is detected
					[2]: the airbag is activated within 5 ms
					[3]: after an emergency signal is sent for 10 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if a crash is detected
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the airbag is activated
						SlotType= TimeScope|| Text= within 5 ms
					C[3]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= after an emergency signal is sent
						SlotType= TimeScope|| Text= for 10 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if a crash is detected
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: a crash
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is detected
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: detect
							TechnicalOperator: =
							PredicateFormal: a crash.crrStatus = detect
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the airbag is activated
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the airbag
							</ArgDetails>
						</Operands>
						<Operator>
							relation:is activated
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: activate
							TechnicalOperator: =
							PredicateFormal: the airbag.crrStatus = activate
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 5
							Unit: ms
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 5
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
						<ActionScope>
							<ConditionalScope>
								scope phase: StartUpPhase
								<Condition>
									Keyword: null
									Text = after an emergency signal is sent
									<Operands>
										Arg[0]
										<ArgDetails>
											Text: an emergency signal
										</ArgDetails>
									</Operands>
									<Operator>
										relation:is sent
									</Operator>
									Has valid-time:  true
									<ValidTime>
										TimeType: Scope
										Value: 10
										Unit: seconds
										QPRelation: null
									<FormalSemantic>
										TechnicalOperator: =
										Value: 10
										</FormalSemantic>
									<ValidTime>
									Is negatted: false
									<FormalSemantic>
										LHS: Arg[0].crrStatus
										RHS: send
										TechnicalOperator: =
										PredicateFormal: an emergency signal.crrStatus = send
									</FormalSemantic>
								</Condition>
							</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_19:]
		text: if it rains for 1 minute, the wipers are active for 30 seconds within 1 minute.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if it rains for 1 minute, the wipers are active for 30 seconds within 1 minute.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [(G{t=1}(P))] ==> [(F{t=1}(G{t=30}(Q)))] )
					MTL-Formula: G( [(G{t=1}(it.crrStatus = rain))] ==> [(F{t=1}(G{t=30}(the wipers = active)))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if it rains for 1 minute
					[2]: the wipers are active for 30 seconds within 1 minute
				</ExtractedComponents>
				<ClassifiedComponents>
					C[1]==>	Type: cond 
						SlotType= MainSlot|| Text= if it rains
						SlotType= TimeScope|| Text= for 1 minute
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the wipers are active
						SlotType= TimeScope|| Text= within 1 minute
						SlotType= TimeScope|| Text= for 30 seconds
				</ClassifiedComponents>
				<RCMDetails>
					
					<Condition>
						Keyword: if
						Text = if it rains
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: it
							</ArgDetails>
						</Operands>
						<Operator>
							relation:rains
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: rain
							TechnicalOperator: =
							PredicateFormal: it.crrStatus = rain
						</FormalSemantic>
					</Condition>
					<Action>
						Text = the wipers are active
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the wipers
							</ArgDetails>
							Arg[1]
							<ArgDetails>
								Text: active
							</ArgDetails>
						</Operands>
						<Operator>
							relation:are
						</Operator>
						Has valid-time:  true
						<ValidTime>
							TimeType: Scope
							Value: 30
							Unit: seconds
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 30
							</FormalSemantic>
						<ValidTime>
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0]
							RHS: Arg[1]
							TechnicalOperator: =
							PredicateFormal: the wipers = active
						</FormalSemantic>
						is repeated = false
						<PreElapsedTime>
							TimeType: PreElapsed
							Value: 1
							Unit: minute
							QPRelation: null
						<FormalSemantic>
							TechnicalOperator: =
							Value: 1
							</FormalSemantic>
						<PreElapsedTime>
					</Action>
					<RequirementScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

	<Requirement>
		ID: [req_29:]
		text: if the in front vehicle decelerates, the vehicle decelerates before the safety_distance is restored for at most 2 seconds.

		<PrimitiveReq>
			<PR>
				Id: [1]
				text: if the in front vehicle decelerates, the vehicle decelerates before the safety_distance is restored for at most 2 seconds.
				<Formal-Representation>
					MTL-AbbrevatedFormula: G( [F(G{t<=2}(Q)) ==> (F((P) || (G{t<=2}(Q)) ) U (G{t<=2}(Q)))] )
					MTL-Formula: G( [F(G{t<=2}(the safety_distance.crrStatus = restore)) ==> (F((the vehicle.crrStatus = decelerate) || (G{t<=2}(the safety_distance.crrStatus = restore)) ) U (G{t<=2}(the safety_distance.crrStatus = restore)))] )
				</Formal-Representation>
				<ExtractedComponents>
					[1]: if the in front vehicle decelerates
					[2]: the vehicle decelerates
					[3]: before the safety_distance is restored for at most 2 seconds
				</ExtractedComponents>
				<ClassifiedComponents>
				        C[1]==>	Type: cond 
						SlotType= MainSlot|| Text=  if the in front vehicle decelerates
					C[2]==>	Type: act 
						SlotType= MainSlot|| Text= the vehicle decelerates
					C[3]==>	Type: actScope 
						SlotType= ConditionalScope|| Text= before the safety_distance is restored
						SlotType= TimeScope|| Text= for at  most 2 seconds
				</ClassifiedComponents>
				<RCMDetails>
					<Condition>
						Text = if the in front vehicle decelerates
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the in front vehicle
							</ArgDetails>
						</Operands>
						<Operator>
							relation:decelerates
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: decelerate
							TechnicalOperator: =
							PredicateFormal: the in front vehicle.crrStatus = decelerate
						</FormalSemantic>
						is repeated = false
					</Condition>
					<Action>
						Text = the vehicle decelerates
						<Operands>
							Arg[0]
							<ArgDetails>
								Text: the vehicle
							</ArgDetails>
						</Operands>
						<Operator>
							relation:decelerates
						</Operator>
						Has valid-time:  false
						Is negatted: false
						<FormalSemantic>
							LHS: Arg[0].crrStatus
							RHS: decelerate
							TechnicalOperator: =
							PredicateFormal: the vehicle.crrStatus = decelerate
						</FormalSemantic>
						is repeated = false
					</Action>
					<RequirementScope>
						<ActionScope>
							<ConditionalScope>
								scope phase: EndUpPhase
								<Condition>
									Keyword: null
									Text = before the safety_distance is restored
									<Operands>
										Arg[0]
										<ArgDetails>
											Text: the safety_distance
										</ArgDetails>
									</Operands>
									<Operator>
										relation:is restored
									</Operator>
									Has valid-time:  true
									<ValidTime>
										TimeType: Scope
										Value: 2
										Unit: seconds
										QPRelation: at  most
									<FormalSemantic>
										TechnicalOperator: <=
										Value: 2
										</FormalSemantic>
									<ValidTime>
									Is negatted: false
									<FormalSemantic>
										LHS: Arg[0].crrStatus
										RHS: restore
										TechnicalOperator: =
										PredicateFormal: the safety_distance.crrStatus = restore
									</FormalSemantic>
								</Condition>
							</ConditionalScope>
						</ActionScope>
					</RequirementScope>
				</RCMDetails>
			</PR>
		</PrimitiveReq>
	</Requirement>

</SucceededRequirement>
</log>
